//! Streaming translation between Serde data formats.
//!
//! xt's streaming transcoder is inspired by the [`serde_transcode`] crate advertised in the Serde
//! documentation. However, its implementation has diverged significantly to enable preservation of
//! original (de)serializer error values, in contrast to `serde_transcode` stringifying errors to
//! meet Serde API requirements.
//!
//! This capability comes at the cost of significant implementation complexity. If it's not an
//! absolute requirement for your use case, you should probably stick with the simpler,
//! more mature, and more popular `serde_transcode`.
//!
//! [`serde_transcode`]: https://github.com/sfackler/serde-transcode

use std::cell::Cell;
use std::error;
use std::fmt;

use serde::de::{self, DeserializeSeed, Deserializer};
use serde::ser::{self, Serialize, SerializeMap, SerializeSeq, Serializer};

/// The message used to generate generic serializer and deserializer errors.
///
/// When transcoding fails due to a serializer error, this message could make its way into the text
/// of the resulting deserializer error, depending on the specific deserializer in use.
const TRANSLATION_FAILED: &str = "translation failed";

/// Transcodes from a Serde `Deserializer` to a Serde `Serializer`.
///
/// The transcoding process forwards values produced by a deserializer directly to a serializer,
/// without collecting the entire output of the deserializer into an intermediate data structure.
///
/// An error in either the serializer or deserializer immediately halts transcoding.
/// See [`Error`] for information about how to interpret a transcoding error.
///
/// # Caveats
///
/// - The transcoder doesn't validate the deserializer's output in any meaningful way. For example,
///   it doesn't impose recursion limits on the deserialized data, nor does it prevent
///   deserialization of values that the serializer doesn't support.
///
/// - Transcoding is only possible for self-describing data formats; that is, formats where the
///   types of values can be determined from the serialized representation itself.
///
/// - While the transcoding process itself doesn't collect the deserializer's entire output,
///   certain (de)serializers may do so as part of their implementation.
///
/// - The current transcoder implementation doesn't handle all types supported by Serde. It only
///   handles types that a deserializer for a self-describing data format would reasonably be
///   expected to produce (i.e. not Rust-specific types like `Option<T>` or newtype structs).
pub(crate) fn transcode<'de, S, D>(ser: S, de: D) -> Result<S::Ok, Error<S::Error, D::Error>>
where
	S: Serializer,
	D: Deserializer<'de>,
{
	let mut visitor = Visitor::new(ser);
	de.deserialize_any(&mut visitor)
		.map_err(|de_err| match visitor.0.error_source() {
			ErrorSource::Ser => Error::Ser(visitor.0.into_error().unwrap(), de_err),
			ErrorSource::De => Error::De(de_err),
		})
}

/// Holds an error produced during transcoding.
///
/// A transcoding error indicates which side of the transcode originally triggered the failure, and
/// provides access to the original error value(s) generated by the serializer and/or deserializer.
#[derive(Debug)]
pub(crate) enum Error<S, D>
where
	S: ser::Error,
	D: de::Error,
{
	/// The serializer triggered the transcode failure, for example due to an input value it
	/// couldn't handle. The included deserializer error may provide useful context, such as the
	/// line and column where transcoding failed.
	Ser(S, D),
	/// The deserializer triggered the transcode failure, for example due to a syntax error
	/// in the input.
	De(D),
}

impl<S, D> fmt::Display for Error<S, D>
where
	S: ser::Error,
	D: de::Error,
{
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		match self {
			Error::Ser(ser_err, de_err) => write!(f, "{de_err}: {ser_err}"),
			Error::De(de_err) => fmt::Display::fmt(de_err, f),
		}
	}
}

impl<S, D> error::Error for Error<S, D>
where
	S: ser::Error + 'static,
	D: de::Error + 'static,
{
	fn source(&self) -> Option<&(dyn error::Error + 'static)> {
		match self {
			Error::Ser(ser_err, _) => Some(ser_err),
			Error::De(de_err) => Some(de_err),
		}
	}
}

/// The internal representation of the side of the transcode operation that originally failed.
///
/// Since the transcoder may need to generate a synthetic serializer error to back out from a
/// deserializer failure, the fact that a serializer error made it up the call stack doesn't mean
/// the serializer caused the failure. The transcoder explicitly tracks this so it can discard its
/// synthetic errors instead of returning them to the user.
#[derive(Clone, Copy)]
enum ErrorSource {
	De,
	Ser,
}

/// The internal state of a single transcoding step, holding data that can't cross normal
/// Serde API boundaries.
///
/// The transcoding process relies on special implementations of key Serde traits like
/// [`Serialize`] and [`de::Visitor`]. To preserve the original values of (de)serializer errors
/// across Serde API boundaries that can't represent them directly, and to account for the fact
/// that many Serde trait methods consume `self`, the transcoder's implementations of Serde trait
/// methods follow a common pattern:
///
/// 1. Take ownership of some "parent" value: either the serializer to which the next deserialized
///    value should be forwarded, or the deserializer that will produce the next value.
///
/// 2. Call some method of the parent, possibly with a value that was passed to us as an argument,
///    consuming the parent and producing a [`Result`] of generic value and error types.
///
/// 3. If the parent returned an error that we can't return directly, capture that original error
///    value (and its source) and instead return whatever error type our method signature requires,
///    either by extracting it from a child `State` or constructing it with a well-known message
///    string (which is the only capability that Serde's error traits require; they can't be
///    constructed with arbitrary payloads).
///
/// This type is designed to facilitate this pattern, generally as part of a newtype struct that
/// implements a specific Serde trait.
struct State<P, E> {
	// Only Forwarder actually needs interior mutability, due to `serialize` taking `&self`.
	// However, two obvious ways of moving the interior mutability into Forwarder end up hurting
	// transcoding performance:
	//
	// 1. When removing Cell from these fields but otherwise leaving the layout as-is, performance
	//    slows by as much as 15% - 25%, especially on formats like MessagePack that aren't
	//    expensive to encode or decode on their own.
	//
	// 2. When turning this into an enum (with empty, parent, and error states), the impact is
	//    closer to 5%. Not as bad, but still measurable and consistent.
	//
	// These numbers are based on Forwarder using Cell for interior mutability, but RefCell doesn't
	// improve them either. I can only guess at the optimizations or CPU microarchitectural effects
	// that might be at play. My suspicion is that this version somehow minimizes data copying, but
	// I don't know how to confirm or deny that hypothesis.
	//
	// Serde traits are implemented on `&mut` references where possible to help mark where mutation
	// is happening, even though `&` would technically work.
	parent: Cell<Option<P>>,
	error: Cell<Option<E>>,
	source: Cell<ErrorSource>,
}

impl<P, E> State<P, E> {
	/// Creates a new state holding the provided parent value.
	fn new(parent: P) -> State<P, E> {
		State {
			parent: Cell::new(Some(parent)),
			error: Cell::new(None),
			// Errors are assumed to come from the deserializer by default. Since the transcoder
			// drives the serializer, it always knows when it needs to overwrite this.
			source: Cell::new(ErrorSource::De),
		}
	}

	/// Returns the contained parent value, as long as it was not previously
	/// taken.
	///
	/// # Panics
	///
	/// Panics if the parent value has already been taken from this state.
	fn take_parent(&self) -> P {
		self.parent
			.replace(None)
			.expect("parent already taken from this state")
	}

	/// Captures an error for later extraction, and records the provided source (serializer or
	/// deserializer) as the source of the error.
	fn capture_error(&self, source: ErrorSource, error: E) {
		self.source.set(source);
		self.error.set(Some(error));
	}

	/// Consumes and captures both the error value and error source from another state.
	fn capture_child_error<C>(&self, child: State<C, E>) {
		self.source.set(child.error_source());
		self.error.set(child.into_error());
	}

	/// Returns the source (serializer or deserializer) of any error associated with this state.
	fn error_source(&self) -> ErrorSource {
		self.source.get()
	}

	/// Returns the captured error, if any, consuming the `self` value.
	fn into_error(self) -> Option<E> {
		self.error.into_inner()
	}
}

/// Takes the next value produced by a [`Deserializer`] and forwards it to a [`Serializer`].
///
/// The deserializer's [`Deserializer::deserialize_any`] drives the transcoding process by calling
/// the [`de::Visitor`] method corresponding to the type of value it sees in the input.
struct Visitor<S: Serializer>(State<S, S::Error>);

impl<S: Serializer> Visitor<S> {
	fn new(ser: S) -> Visitor<S> {
		Visitor(State::new(ser))
	}

	/// Provides the error capturing and mapping boilerplate for all visitor methods that handle
	/// basic scalar types (booleans, numbers, etc.), where the only meaningful difference between
	/// methods is which [`Serializer`] method they need to call. Having this in a function (rather
	/// than inlined into a macro body) makes it easier for rust-analyzer to inspect.
	fn forward_scalar<F, E>(&mut self, use_serializer: F) -> Result<S::Ok, E>
	where
		F: FnOnce(S) -> Result<S::Ok, S::Error>,
		E: de::Error,
	{
		let ser = self.0.take_parent();
		use_serializer(ser).map_err(|ser_err| {
			self.0.capture_error(ErrorSource::Ser, ser_err);
			de::Error::custom(TRANSLATION_FAILED)
		})
	}
}

/// Implements the simplest [`de::Visitor`] methods that forward scalars to a [`Serializer`].
macro_rules! impl_forward_scalar_visitors {
	( $( $name:ident($($arg:ident: $ty:ty)?) => $op:expr; )* ) => {
		$(fn $name<E: de::Error>(self, $($arg: $ty)?) -> Result<Self::Value, E> {
			self.forward_scalar($op)
		})*
	};
}

impl<'de, S: Serializer> de::Visitor<'de> for &mut Visitor<S> {
	// It's important to note that we don't implement error preservation by having the visitor
	// return `Result<S::Ok, S::Error>`, which might seem at first like the obvious way to do
	// things. That approach requires one of two things to happen when the transcoder encounters a
	// serializer error in the middle of a collection (sequence or map), neither of which is ideal:
	//
	// 1. The visitor can try to return the `Result` immediately, without having visited the entire
	//    collection. My experience is that some deserializers panic while unwinding this way.
	//    Maybe that's a bug in the deserializer; it's still not worth the risk.
	//
	// 2. To avoid the panics described in point 1, the visitor can "drain" the rest of the
	//    collection before it returns the final `Result`, e.g. by deserializing into `IgnoredAny`.
	//    This works, but wastes a lot of effort for an operation that we know will fail.
	//
	// Unlike the `Result` approach, the error capturing and mapping approach ensures that a failed
	// transcode follows normal error handling paths in both the serializer and deserializer.
	type Value = S::Ok;

	fn expecting(&self, f: &mut fmt::Formatter) -> fmt::Result {
		f.write_str("any supported value")
	}

	impl_forward_scalar_visitors! {
		visit_unit() => |ser| ser.serialize_unit();

		visit_bool(v: bool) => |ser| ser.serialize_bool(v);

		visit_i8(v: i8) => |ser| ser.serialize_i8(v);
		visit_i16(v: i16) => |ser| ser.serialize_i16(v);
		visit_i32(v: i32) => |ser| ser.serialize_i32(v);
		visit_i64(v: i64) => |ser| ser.serialize_i64(v);
		visit_i128(v: i128) => |ser| ser.serialize_i128(v);

		visit_u8(v: u8) => |ser| ser.serialize_u8(v);
		visit_u16(v: u16) => |ser| ser.serialize_u16(v);
		visit_u32(v: u32) => |ser| ser.serialize_u32(v);
		visit_u64(v: u64) => |ser| ser.serialize_u64(v);
		visit_u128(v: u128) => |ser| ser.serialize_u128(v);

		visit_f32(v: f32) => |ser| ser.serialize_f32(v);
		visit_f64(v: f64) => |ser| ser.serialize_f64(v);

		visit_char(v: char) => |ser| ser.serialize_char(v);
		visit_str(v: &str) => |ser| ser.serialize_str(v);
		visit_bytes(v: &[u8]) => |ser| ser.serialize_bytes(v);
	}

	fn visit_seq<A: de::SeqAccess<'de>>(self, mut de: A) -> Result<Self::Value, A::Error> {
		let parent = self.0.take_parent();
		let mut seq = parent.serialize_seq(de.size_hint()).map_err(|ser_err| {
			self.0.capture_error(ErrorSource::Ser, ser_err);
			de::Error::custom(TRANSLATION_FAILED)
		})?;

		loop {
			let mut seed = SeqSeed::new(&mut seq);
			match de.next_element_seed(&mut seed) {
				Ok(None) => break,
				Ok(Some(())) => {}
				Err(de_err) => {
					self.0.capture_child_error(seed.0);
					return Err(de_err);
				}
			}
		}

		seq.end().map_err(|ser_err| {
			self.0.capture_error(ErrorSource::Ser, ser_err);
			de::Error::custom(TRANSLATION_FAILED)
		})
	}

	fn visit_map<A: de::MapAccess<'de>>(self, mut de: A) -> Result<Self::Value, A::Error> {
		let parent = self.0.take_parent();
		let mut map = parent.serialize_map(de.size_hint()).map_err(|ser_err| {
			self.0.capture_error(ErrorSource::Ser, ser_err);
			de::Error::custom(TRANSLATION_FAILED)
		})?;

		loop {
			let mut key_seed = KeySeed::new(&mut map);
			match de.next_key_seed(&mut key_seed) {
				Ok(None) => break,
				Ok(Some(())) => {}
				Err(de_err) => {
					self.0.capture_child_error(key_seed.0);
					return Err(de_err);
				}
			}

			let mut value_seed = ValueSeed::new(&mut map);
			if let Err(de_err) = de.next_value_seed(&mut value_seed) {
				self.0.capture_child_error(value_seed.0);
				return Err(de_err);
			}
		}

		map.end().map_err(|ser_err| {
			self.0.capture_error(ErrorSource::Ser, ser_err);
			de::Error::custom(TRANSLATION_FAILED)
		})
	}
}

/// A serializable "value" that actually serializes the next value produced by a [`Deserializer`].
///
/// This is required to transcode the individual elements of collections like sequences and maps,
/// as the serializer traits responsible for these types can only accept values implementing
/// [`Serialize`].
///
/// Unlike most serializable types, a `Forwarder` can only be serialized once, and panics if
/// serialized more than once.
struct Forwarder<'de, D: Deserializer<'de>>(State<D, D::Error>);

impl<'de, D: Deserializer<'de>> Forwarder<'de, D> {
	fn new(de: D) -> Forwarder<'de, D> {
		Forwarder(State::new(de))
	}

	/// Provides the error capturing and mapping boilerplate for a single element of a collection,
	/// which is associated with a particular Serde trait and collection-specific methods (e.g. to
	/// distinguish map keys and values).
	fn serialize_with_seed<S, SErr, F>(
		self,
		seed_state: &mut State<S, SErr>,
		use_serializer: F,
	) -> Result<(), D::Error>
	where
		F: FnOnce(S, &Self) -> Result<(), SErr>,
	{
		// &self has interior mutability, so serialization may capture an error and source into
		// the state at self.0.
		let ser = seed_state.take_parent();
		use_serializer(ser, &self).map_err(|ser_err| {
			seed_state.capture_error(self.0.error_source(), ser_err);
			self.0
				.into_error()
				.unwrap_or_else(|| de::Error::custom(TRANSLATION_FAILED))
		})
	}
}

impl<'de, D: Deserializer<'de>> Serialize for Forwarder<'de, D> {
	fn serialize<S: Serializer>(&self, ser: S) -> Result<S::Ok, S::Error> {
		let mut visitor = Visitor::new(ser);
		let de = self.0.take_parent();
		de.deserialize_any(&mut visitor).map_err(|de_err| {
			self.0.capture_error(visitor.0.error_source(), de_err);
			visitor
				.0
				.into_error()
				.unwrap_or_else(|| ser::Error::custom(TRANSLATION_FAILED))
		})
	}
}

/// Receives the next value of a sequence (from [`de::SeqAccess`]) and forwards it to a sequence
/// serializer (through [`ser::SerializeSeq`]).
struct SeqSeed<'ser, S: SerializeSeq>(State<&'ser mut S, S::Error>);

impl<'ser, S: SerializeSeq> SeqSeed<'ser, S> {
	fn new(ser: &'ser mut S) -> SeqSeed<'ser, S> {
		SeqSeed(State::new(ser))
	}
}

impl<'de, S: SerializeSeq> DeserializeSeed<'de> for &mut SeqSeed<'_, S> {
	type Value = ();

	fn deserialize<D: Deserializer<'de>>(self, de: D) -> Result<(), D::Error> {
		Forwarder::new(de)
			.serialize_with_seed(&mut self.0, |ser, element| ser.serialize_element(element))
	}
}

/// Receives a map key (from [`de::MapAccess`]) and forwards it to a map serializer
/// (through [`ser::SerializeMap`]).
struct KeySeed<'ser, S: SerializeMap>(State<&'ser mut S, S::Error>);

impl<'ser, S: SerializeMap> KeySeed<'ser, S> {
	fn new(ser: &'ser mut S) -> KeySeed<'ser, S> {
		KeySeed(State::new(ser))
	}
}

impl<'de, S: SerializeMap> DeserializeSeed<'de> for &mut KeySeed<'_, S> {
	type Value = ();

	fn deserialize<D: Deserializer<'de>>(self, de: D) -> Result<(), D::Error> {
		Forwarder::new(de).serialize_with_seed(&mut self.0, |ser, key| ser.serialize_key(key))
	}
}

/// Receives a map value (from [`de::MapAccess`]) and forwards it to a map serializer
/// (through [`ser::SerializeMap`]).
struct ValueSeed<'ser, S: SerializeMap>(State<&'ser mut S, S::Error>);

impl<'ser, S: SerializeMap> ValueSeed<'ser, S> {
	fn new(ser: &'ser mut S) -> ValueSeed<'ser, S> {
		ValueSeed(State::new(ser))
	}
}

impl<'de, S: SerializeMap> DeserializeSeed<'de> for &mut ValueSeed<'_, S> {
	type Value = ();

	fn deserialize<D: Deserializer<'de>>(self, de: D) -> Result<(), D::Error> {
		Forwarder::new(de).serialize_with_seed(&mut self.0, |ser, value| ser.serialize_value(value))
	}
}
